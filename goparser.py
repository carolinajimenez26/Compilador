# goparser.py# -*- coding: utf-8 -*-'''Proyecto 2:  Escribir un parser===============================En este proyecto, se escribe la estructura basica de una analizador parael lenguaje hoc. La forma BNF del lenguaje se describe a continuacion.Su tarea es escribir las reglas de análisis y construir el AST para estagramática usando PLY.program : statements        | emptystatements :  statements statement           |  statementstatement :  const_declaration          |  var_declaration          |  extern_declaration          |  assign_statement          |  print_statement          |  if_statementconst_declaration : CONST ID = expression SEMIvar_declaration : VAR ID typename SEMI                | VAR ID typename = expression SEMIextern_declaration : EXTERN func_prototype SEMIfunc_prototype : FUNC ID LPAREN parameters RPAREN typenameparameters : parameters , parm_declaration           | parm_declaration           | emptyparm_declaration : ID typenameassign_statement : location = expression SEMIprint_statement : PRINT expression SEMIexpression : + expression           | - expression           | expression + expression           | expression - expression           | expression * expression           | expression / expression           | ( expression )           | ID ( exprlist )           | location           | literalexprlist : exprlist , expression           | expression           | emptyliteral : INTEGER        | FLOAT        | STRINGlocation : IDtypename : IDempty    :Para hacer el proyecto, siga las instrucciones a continuación.'''# ----------------------------------------------------------------------# Los parsers son definidos usando el módulo yacc de PLY## Vea http://www.dabeaz.com/ply/ply.html#ply_nn23# ----------------------------------------------------------------------from ply import yacc# ----------------------------------------------------------------------# El siguiente import carga la funcion error(lineno, msg) que debe ser# usada para reportar todos los mensajes de error generados por su parser.# Las pruebas Unitarias y otras caracteristicas del compilador se basaran# en esta función.  vea el archivo errors.py para una mayor documentación# acerca del mecanismo de manejo de errores.from errors import error# ----------------------------------------------------------------------# Obtener la lista de token definidos en el módulo lexer.  Esto es# necesario con el fin de validar y construir la tabla de sintaxis.from golex import tokens# ----------------------------------------------------------------------# Obtener los nodos del AST.# Lea las instrucciones en hocast.pyfrom goast import *# ----------------------------------------------------------------------# Tabla de precedencia de operadores.  Los operadores deben de seguir# las mismas reglas de precedencia que Python.  Instrucciones que se# dan el el proyecto.# Vea http://www.dabeaz.com/ply/ply.html#ply_nn27precedence = (    ('right', 'ASSIGN', 'POSITIVEINCREASE','NEGATIVEINCREASE', 'MULTIPLIINCREASE', 'DIVIDEINCREASE', 'EVADETYPEDECLAR'),    ('left', 'LOR'),    ('left', 'LAND'),    ('left', 'LNOT'),    ('nonassoc', 'LT', 'LE', 'EQ', 'GT', 'GE', 'NE'),    ('left', 'PLUS', 'MINUS', 'OR'),    ('left', 'TIMES', 'DIVIDE', 'RESIDUE', 'AND', 'COMMA'),    # Operador ficticio para mantener la mas alta prioridad    ('left', 'UNARY', 'INCREASE', 'DECREMENT', 'LPAREN', 'LBRACE', 'LBRACKET', 'RETURN'),    ('right', 'RBRACE', 'RPAREN', 'RBRACKET'),)# ----------------------------------------------------------------------# SU TAREA.  Traducir la forma BNF en la cadena de documentación mencionada# anteriormente dentro de una colección de funciones del parser.  Por# ejemplo, una regla tal como:##   program : statements## Se convierte en una función de Python de la forma:## def p_program(p):#      '''#      program : statements#      '''#      p[0] = Program(p[1])## Para los símbolos tales com '(' or '+', deberá reemplazarlos con el# nombre del correspondiente token tal como LPAREN o PLUS (si así lo# hizo en el lexer).## En el cuerpo de cada regla, cree un nodo apropiado del AST y asignelo# a p[0] como se muestró anteriormente.## Para el seguimiento del numero de linea, se debe asignar un numero de linea# para cada nodo del AST como corresponda.  Para ello, suguiero utilizar el# numero de línea del símbolo terminal mas cercano.  Por ejemplo:## def p_print_statement(p):#     '''#     print_statement: PRINT expr SEMI#     '''#     p[0] = PrintStatement(p[2],lineno=p.lineno(1))### EMPEZAR# =======# Las siguientes reglas gramaticales deben de darle una idea de como empezar.# Trate de correrlo con un archivo de prueba.def p_program(p):    '''    program : statements            | empty    '''    p[0] = Program(p[1])def p_statements(p):    '''    statements :  statements statement    '''    p[0] = p[1]    p[0].append(p[2])    # p[0] = [statements, statement]def p_statements_1(p):    '''    statements :  statement    '''    p[0] = Statements([p[1]])#https://golang.org/ref/spec#Statementsdef p_statement(p):    '''    statement :  const_declaration          |  var_declaration          |  extern_declaration          |  assign_statement          |  short_declaration          |  print_statement          |  if_statement          |  while_statement          |  for_statement          |  expression_funcall          |  return_statement          |  opper_statement          |  func_declaration          |  read_statement          |  write_statement    '''    p[0] = Statement(p[1])def p_const_declaration(p):    '''    const_declaration : CONST ID ASSIGN expression semi_optional    '''    p[0] = ConstDeclaration(p[2],p[4])    # const_declaration = Nodo(ID,expresion)def p_var_declaration(p):    '''    var_declaration : VAR ID typename semi_optional    '''    p[0] = VarDeclaration(p[2], p[3], None, None, lineno=p.lineno(2))def p_var_declaration_1(p):    '''    var_declaration : VAR ID typename ASSIGN expression semi_optional    '''    p[0] = VarDeclaration(p[2], p[3], p[5], None)def p_extern_declaration(p):    '''    extern_declaration : EXTERN func_prototype semi_optional    '''    p[0] = Extern(p[2])def p_func_prototype(p):    '''    func_prototype : FUNC ID LPAREN parameters RPAREN typename    '''    p[0] = FuncPrototype(p[2], p[4], p[6])def p_parameters(p):    '''    parameters : parameters COMMA parm_declaration    '''    p[0] = p[1]    p[0].append(p[3])def p_parameters_1(p):    '''    parameters : parm_declaration           | empty    '''    p[0] = Parameters([p[1]])def p_parm_declaration(p):    '''    parm_declaration : ID typename    '''    p[0] = ParamDecl(p[1], p[2], None)def p_assign_statement(p):    '''    assign_statement : location ASSIGN expression semi_optional            | location POSITIVEINCREASE expression semi_optional            | location NEGATIVEINCREASE expression semi_optional            | location MULTIPLIINCREASE expression semi_optional            | location DIVIDEINCREASE expression semi_optional            | location ASSIGN expression_funcall    '''    p[0] = AssignmentStatement(p[1], p[3], p[2])def p_print_statement(p):    '''    print_statement : PRINT expression semi_optional            | PRINT expression_funcall semi_optional    '''    #import pydb; pydb.debugger()    p[0] = PrintStatement(p[2])def p_expression_unary(p):    '''    expression :  PLUS expression %prec UNARY           |  MINUS expression %prec UNARY           |  LNOT expression %prec UNARY    '''    p[0] = UnaryOp(p[1], p[2], lineno=p.lineno(1))def p_expression_binary(p):    '''    expression :  expression PLUS expression           | expression MINUS expression           | expression TIMES expression           | expression DIVIDE expression           | expression RESIDUE expression    '''    p[0] = BinaryOp(p[2], p[1], p[3])def p_expression_relation(p):    '''    expression : expression LE expression            | expression LT expression            | expression EQ expression            | expression NE expression            | expression GE expression            | expression GT expression            | expression LAND expression            | expression LOR expression            | expression AND expression            | expression OR expression    '''    p[0] = RelationalOp(p[2], p[1], p[3], lineno=p.lineno(2))def p_expression_group(p):    '''    expression : LPAREN expression RPAREN    '''    p[0] = Group(p[2])def p_expression_funcall(p):    '''    expression_funcall :  ID LPAREN exprlist RPAREN semi_optional    '''    p[0] = FunCall(p[1], p[3])def p_if_statement(p):    '''    if_statement : IF expression LBRACE statements RBRACE    '''    p[0] = IfStatement(p[2], p[4], None)def p_if_else_statement(p):    '''    if_statement : IF expression LBRACE statements RBRACE ELSE LBRACE statements RBRACE    '''    p[0] = IfStatement(p[2], p[4], p[8])def p_while_statement(p):    '''    while_statement : WHILE expression LBRACE statements RBRACE    '''    p[0] = WhileStatement(p[2], p[4])def p_expression_location(p):    '''    expression :  location    '''    p[0] = LoadLocation(p[1], lineno=p.lineno(1),isLeaf=True)def p_expression_literal(p):    '''    expression :  literal    '''    p[0] = Literal(p[1],isLeaf=True)def p_exprlist(p):    '''    exprlist :  exprlist COMMA expression    '''    p[0] = p[1]    p[0].append(p[3])def p_exprlist_1(p):    '''    exprlist : expression           | empty    '''    p[0] = ExprList([p[1]])def p_literal(p):    '''    literal : INTEGER            | FLOAT            | STRING            | BOOLEAN    '''    p[0] = Literal(p[1],lineno=p.lineno(1),isLeaf=True)# Usted debe implementar el resto de las reglas de la gramatica# a partir de aqui.def p_semi_optional(p):    '''    semi_optional : SEMI            | empty    '''def p_return_statement(p):    '''    return_statement : RETURN expression semi_optional            | RETURN expression_funcall semi_optional    '''    p[0] = Return(p[2])def p_for_statement(p):    '''    for_statement : FOR cond1 expression SEMI cond2 LBRACE statements RBRACE    '''    p[0] = ForStatement(p[2], p[3], p[5], p[7])def p_cond1(p):    '''    cond1 : var_declaration            | short_declaration    '''    p[0] = Statement(p[1])def p_cond2(p):    '''    cond2 : expression            | assign_statement            | opper_statement    '''    p[0] = Statement(p[1])def p_short_declaration(p):    '''    short_declaration : location EVADETYPEDECLAR expression semi_optional    '''    p[0] = AssignmentStatement(p[1], p[3], p[2])def p_opper_statement(p):    '''    opper_statement : location INCREASE            | location DECREMENT    '''    p[0] = Opper(p[1],p[2])def p_location(p):    '''    location : ID    '''    p[0] = Location(p[1], None, isLeaf=True)def p_func_declaration(p):    '''    func_declaration : FUNC ID LPAREN parameters RPAREN typename LBRACE statements RBRACE    '''    p[0] = FuncDeclaration(p[2], p[4], p[6], p[8])def p_var_vector_declaration(p):    '''    var_declaration : VAR ID typename vector_declaration semi_optional    '''    p[0] = VarDeclaration(p[2], p[3], None, p[4], lineno=p.lineno(2))def p_parm_vector_declaration(p):    '''    parm_declaration : ID typename vector_declaration    '''    p[0] = ParamDecl(p[1], p[2], p[3])def p_vector_assign_statement(p):    '''    assign_statement : location_vector ASSIGN expression semi_optional            | location_vector POSITIVEINCREASE expression semi_optional            | location_vector NEGATIVEINCREASE expression semi_optional            | location_vector MULTIPLIINCREASE expression semi_optional            | location_vector DIVIDEINCREASE expression semi_optional            | location_vector EVADETYPEDECLAR expression semi_optional    '''    p[0] = AssignmentStatement(p[1], p[3], p[2])def p_vector_location(p):    '''    location_vector : ID vector_expression    '''    p[0] = Location(p[1], p[2])def p_vector_expression_location(p):    '''    expression : ID vector_expression    '''    p[0] = Location(p[1], p[2])def p_entero(p):    '''    entero : INTEGER    '''    p[0] = Number(p[1], isLeaf=True)def p_vector_declaration(p):    '''    vector_declaration : LBRACKET location RBRACKET            | LBRACKET entero RBRACKET    '''    p[0] = VectorStatement(p[2])def p_vector_expression(p):    '''    vector_expression : LBRACKET expression RBRACKET    '''    p[0] = VectorStatement(p[2])def p_read_statement(p):    '''    read_statement : READ LPAREN expression RPAREN semi_optional    '''    p[0] = ReadStatement(p[3])def p_write_statement(p):    '''    write_statement : WRITE LPAREN expression RPAREN semi_optional    '''    p[0] = WriteStatement(p[3])def p_typename(p):    '''    typename : FLOAT            | STRING            | INT            | BOOL    '''    p[0] = TypeName(p[1],lineno=p.lineno(1),isLeaf=True)def p_empty(p):    '''    empty    :    '''# ----------------------------------------------------------------------# NO MODIFIQUE## capturar todos los errores.  La siguiente función es llamada si existe# una entrada mala. Vea http://www.dabeaz.com/ply/ply.html#ply_nn31def p_error(p):    if p:        error(p.lineno, "Error de sintaxis de entrada en token '%s'" % p.value)    else:        error("EOF","Error de sintaxis. No hay mas entrada.")def p_literal_error(p):    'statement : PRINT error SEMI'    print("Error en los literales")# ----------------------------------------------------------------------#              NO MODIFIQUE NADA DE AQUI EN ADELANTE# ----------------------------------------------------------------------def make_parser():    parser = yacc.yacc()    return parserif __name__ == '__main__':    import golex    import sys    from errors import subscribe_errors    lexer = golex.make_lexer()    parser = make_parser()    with subscribe_errors(lambda msg: sys.stdout.write(msg+"\n")):        program = parser.parse(open(sys.argv[1]).read())    # Output the resulting parse tree structure    """print ("....")    for depth,node in flatten(program):        print("%s    %s" % (" "*(4*depth),node))    print ("....")"""    #flatten(program)    if program:        dot = DotVisitor()        dot.visit(program)        dot.printGraph("salida.png")    else:        print ("Error al crear el parser")